/* Generated by ./src/xlat/gen.sh from ./src/xlat/kd_key_ascii_keys.in; do not edit. */

#include "gcc_compat.h"
#include "static_assert.h"

#if defined(K_ASC0) || (defined(HAVE_DECL_K_ASC0) && HAVE_DECL_K_ASC0)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_ASC0) == (K(KT_ASCII,0)), "K_ASC0 != K(KT_ASCII,0)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_ASC0 K(KT_ASCII,0)
#endif
#if defined(K_ASC0) || (defined(HAVE_DECL_K_ASC0) && HAVE_DECL_K_ASC0)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_ASC0)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_ASC0"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_ASC0)
#endif
#if defined(K_ASC1) || (defined(HAVE_DECL_K_ASC1) && HAVE_DECL_K_ASC1)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_ASC1) == (K(KT_ASCII,1)), "K_ASC1 != K(KT_ASCII,1)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_ASC1 K(KT_ASCII,1)
#endif
#if defined(K_ASC1) || (defined(HAVE_DECL_K_ASC1) && HAVE_DECL_K_ASC1)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_ASC1)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_ASC1"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_ASC1)
#endif
#if defined(K_ASC2) || (defined(HAVE_DECL_K_ASC2) && HAVE_DECL_K_ASC2)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_ASC2) == (K(KT_ASCII,2)), "K_ASC2 != K(KT_ASCII,2)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_ASC2 K(KT_ASCII,2)
#endif
#if defined(K_ASC2) || (defined(HAVE_DECL_K_ASC2) && HAVE_DECL_K_ASC2)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_ASC2)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_ASC2"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_ASC2)
#endif
#if defined(K_ASC3) || (defined(HAVE_DECL_K_ASC3) && HAVE_DECL_K_ASC3)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_ASC3) == (K(KT_ASCII,3)), "K_ASC3 != K(KT_ASCII,3)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_ASC3 K(KT_ASCII,3)
#endif
#if defined(K_ASC3) || (defined(HAVE_DECL_K_ASC3) && HAVE_DECL_K_ASC3)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_ASC3)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_ASC3"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_ASC3)
#endif
#if defined(K_ASC4) || (defined(HAVE_DECL_K_ASC4) && HAVE_DECL_K_ASC4)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_ASC4) == (K(KT_ASCII,4)), "K_ASC4 != K(KT_ASCII,4)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_ASC4 K(KT_ASCII,4)
#endif
#if defined(K_ASC4) || (defined(HAVE_DECL_K_ASC4) && HAVE_DECL_K_ASC4)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_ASC4)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_ASC4"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_ASC4)
#endif
#if defined(K_ASC5) || (defined(HAVE_DECL_K_ASC5) && HAVE_DECL_K_ASC5)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_ASC5) == (K(KT_ASCII,5)), "K_ASC5 != K(KT_ASCII,5)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_ASC5 K(KT_ASCII,5)
#endif
#if defined(K_ASC5) || (defined(HAVE_DECL_K_ASC5) && HAVE_DECL_K_ASC5)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_ASC5)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_ASC5"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_ASC5)
#endif
#if defined(K_ASC6) || (defined(HAVE_DECL_K_ASC6) && HAVE_DECL_K_ASC6)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_ASC6) == (K(KT_ASCII,6)), "K_ASC6 != K(KT_ASCII,6)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_ASC6 K(KT_ASCII,6)
#endif
#if defined(K_ASC6) || (defined(HAVE_DECL_K_ASC6) && HAVE_DECL_K_ASC6)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_ASC6)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_ASC6"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_ASC6)
#endif
#if defined(K_ASC7) || (defined(HAVE_DECL_K_ASC7) && HAVE_DECL_K_ASC7)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_ASC7) == (K(KT_ASCII,7)), "K_ASC7 != K(KT_ASCII,7)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_ASC7 K(KT_ASCII,7)
#endif
#if defined(K_ASC7) || (defined(HAVE_DECL_K_ASC7) && HAVE_DECL_K_ASC7)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_ASC7)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_ASC7"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_ASC7)
#endif
#if defined(K_ASC8) || (defined(HAVE_DECL_K_ASC8) && HAVE_DECL_K_ASC8)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_ASC8) == (K(KT_ASCII,8)), "K_ASC8 != K(KT_ASCII,8)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_ASC8 K(KT_ASCII,8)
#endif
#if defined(K_ASC8) || (defined(HAVE_DECL_K_ASC8) && HAVE_DECL_K_ASC8)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_ASC8)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_ASC8"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_ASC8)
#endif
#if defined(K_ASC9) || (defined(HAVE_DECL_K_ASC9) && HAVE_DECL_K_ASC9)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_ASC9) == (K(KT_ASCII,9)), "K_ASC9 != K(KT_ASCII,9)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_ASC9 K(KT_ASCII,9)
#endif
#if defined(K_ASC9) || (defined(HAVE_DECL_K_ASC9) && HAVE_DECL_K_ASC9)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_ASC9)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_ASC9"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_ASC9)
#endif
#if defined(K_HEX0) || (defined(HAVE_DECL_K_HEX0) && HAVE_DECL_K_HEX0)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_HEX0) == (K(KT_ASCII,10)), "K_HEX0 != K(KT_ASCII,10)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_HEX0 K(KT_ASCII,10)
#endif
#if defined(K_HEX0) || (defined(HAVE_DECL_K_HEX0) && HAVE_DECL_K_HEX0)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_HEX0)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_HEX0"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_HEX0)
#endif
#if defined(K_HEX1) || (defined(HAVE_DECL_K_HEX1) && HAVE_DECL_K_HEX1)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_HEX1) == (K(KT_ASCII,11)), "K_HEX1 != K(KT_ASCII,11)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_HEX1 K(KT_ASCII,11)
#endif
#if defined(K_HEX1) || (defined(HAVE_DECL_K_HEX1) && HAVE_DECL_K_HEX1)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_HEX1)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_HEX1"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_HEX1)
#endif
#if defined(K_HEX2) || (defined(HAVE_DECL_K_HEX2) && HAVE_DECL_K_HEX2)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_HEX2) == (K(KT_ASCII,12)), "K_HEX2 != K(KT_ASCII,12)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_HEX2 K(KT_ASCII,12)
#endif
#if defined(K_HEX2) || (defined(HAVE_DECL_K_HEX2) && HAVE_DECL_K_HEX2)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_HEX2)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_HEX2"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_HEX2)
#endif
#if defined(K_HEX3) || (defined(HAVE_DECL_K_HEX3) && HAVE_DECL_K_HEX3)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_HEX3) == (K(KT_ASCII,13)), "K_HEX3 != K(KT_ASCII,13)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_HEX3 K(KT_ASCII,13)
#endif
#if defined(K_HEX3) || (defined(HAVE_DECL_K_HEX3) && HAVE_DECL_K_HEX3)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_HEX3)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_HEX3"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_HEX3)
#endif
#if defined(K_HEX4) || (defined(HAVE_DECL_K_HEX4) && HAVE_DECL_K_HEX4)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_HEX4) == (K(KT_ASCII,14)), "K_HEX4 != K(KT_ASCII,14)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_HEX4 K(KT_ASCII,14)
#endif
#if defined(K_HEX4) || (defined(HAVE_DECL_K_HEX4) && HAVE_DECL_K_HEX4)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_HEX4)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_HEX4"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_HEX4)
#endif
#if defined(K_HEX5) || (defined(HAVE_DECL_K_HEX5) && HAVE_DECL_K_HEX5)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_HEX5) == (K(KT_ASCII,15)), "K_HEX5 != K(KT_ASCII,15)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_HEX5 K(KT_ASCII,15)
#endif
#if defined(K_HEX5) || (defined(HAVE_DECL_K_HEX5) && HAVE_DECL_K_HEX5)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_HEX5)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_HEX5"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_HEX5)
#endif
#if defined(K_HEX6) || (defined(HAVE_DECL_K_HEX6) && HAVE_DECL_K_HEX6)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_HEX6) == (K(KT_ASCII,16)), "K_HEX6 != K(KT_ASCII,16)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_HEX6 K(KT_ASCII,16)
#endif
#if defined(K_HEX6) || (defined(HAVE_DECL_K_HEX6) && HAVE_DECL_K_HEX6)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_HEX6)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_HEX6"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_HEX6)
#endif
#if defined(K_HEX7) || (defined(HAVE_DECL_K_HEX7) && HAVE_DECL_K_HEX7)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_HEX7) == (K(KT_ASCII,17)), "K_HEX7 != K(KT_ASCII,17)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_HEX7 K(KT_ASCII,17)
#endif
#if defined(K_HEX7) || (defined(HAVE_DECL_K_HEX7) && HAVE_DECL_K_HEX7)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_HEX7)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_HEX7"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_HEX7)
#endif
#if defined(K_HEX8) || (defined(HAVE_DECL_K_HEX8) && HAVE_DECL_K_HEX8)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_HEX8) == (K(KT_ASCII,18)), "K_HEX8 != K(KT_ASCII,18)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_HEX8 K(KT_ASCII,18)
#endif
#if defined(K_HEX8) || (defined(HAVE_DECL_K_HEX8) && HAVE_DECL_K_HEX8)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_HEX8)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_HEX8"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_HEX8)
#endif
#if defined(K_HEX9) || (defined(HAVE_DECL_K_HEX9) && HAVE_DECL_K_HEX9)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_HEX9) == (K(KT_ASCII,19)), "K_HEX9 != K(KT_ASCII,19)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_HEX9 K(KT_ASCII,19)
#endif
#if defined(K_HEX9) || (defined(HAVE_DECL_K_HEX9) && HAVE_DECL_K_HEX9)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_HEX9)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_HEX9"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_HEX9)
#endif
#if defined(K_HEXa) || (defined(HAVE_DECL_K_HEXa) && HAVE_DECL_K_HEXa)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_HEXa) == (K(KT_ASCII,20)), "K_HEXa != K(KT_ASCII,20)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_HEXa K(KT_ASCII,20)
#endif
#if defined(K_HEXa) || (defined(HAVE_DECL_K_HEXa) && HAVE_DECL_K_HEXa)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_HEXa)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_HEXa"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_HEXa)
#endif
#if defined(K_HEXb) || (defined(HAVE_DECL_K_HEXb) && HAVE_DECL_K_HEXb)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_HEXb) == (K(KT_ASCII,21)), "K_HEXb != K(KT_ASCII,21)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_HEXb K(KT_ASCII,21)
#endif
#if defined(K_HEXb) || (defined(HAVE_DECL_K_HEXb) && HAVE_DECL_K_HEXb)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_HEXb)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_HEXb"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_HEXb)
#endif
#if defined(K_HEXc) || (defined(HAVE_DECL_K_HEXc) && HAVE_DECL_K_HEXc)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_HEXc) == (K(KT_ASCII,22)), "K_HEXc != K(KT_ASCII,22)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_HEXc K(KT_ASCII,22)
#endif
#if defined(K_HEXc) || (defined(HAVE_DECL_K_HEXc) && HAVE_DECL_K_HEXc)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_HEXc)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_HEXc"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_HEXc)
#endif
#if defined(K_HEXd) || (defined(HAVE_DECL_K_HEXd) && HAVE_DECL_K_HEXd)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_HEXd) == (K(KT_ASCII,23)), "K_HEXd != K(KT_ASCII,23)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_HEXd K(KT_ASCII,23)
#endif
#if defined(K_HEXd) || (defined(HAVE_DECL_K_HEXd) && HAVE_DECL_K_HEXd)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_HEXd)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_HEXd"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_HEXd)
#endif
#if defined(K_HEXe) || (defined(HAVE_DECL_K_HEXe) && HAVE_DECL_K_HEXe)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_HEXe) == (K(KT_ASCII,24)), "K_HEXe != K(KT_ASCII,24)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_HEXe K(KT_ASCII,24)
#endif
#if defined(K_HEXe) || (defined(HAVE_DECL_K_HEXe) && HAVE_DECL_K_HEXe)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_HEXe)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_HEXe"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_HEXe)
#endif
#if defined(K_HEXf) || (defined(HAVE_DECL_K_HEXf) && HAVE_DECL_K_HEXf)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_HEXf) == (K(KT_ASCII,25)), "K_HEXf != K(KT_ASCII,25)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_HEXf K(KT_ASCII,25)
#endif
#if defined(K_HEXf) || (defined(HAVE_DECL_K_HEXf) && HAVE_DECL_K_HEXf)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_HEXf)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_HEXf"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_HEXf)
#endif
#undef XLAT_PREV_VAL

#ifndef XLAT_MACROS_ONLY

# ifdef IN_MPERS

#  error static const struct xlat kd_key_ascii_keys in mpers mode

# else

DIAG_PUSH_IGNORE_TAUTOLOGICAL_CONSTANT_COMPARE
static const struct xlat_data kd_key_ascii_keys_xdata[] = {
 XLAT(K_ASC0),
 #define XLAT_VAL_0 ((unsigned) (K_ASC0))
 #define XLAT_STR_0 STRINGIFY(K_ASC0)
 XLAT(K_ASC1),
 #define XLAT_VAL_1 ((unsigned) (K_ASC1))
 #define XLAT_STR_1 STRINGIFY(K_ASC1)
 XLAT(K_ASC2),
 #define XLAT_VAL_2 ((unsigned) (K_ASC2))
 #define XLAT_STR_2 STRINGIFY(K_ASC2)
 XLAT(K_ASC3),
 #define XLAT_VAL_3 ((unsigned) (K_ASC3))
 #define XLAT_STR_3 STRINGIFY(K_ASC3)
 XLAT(K_ASC4),
 #define XLAT_VAL_4 ((unsigned) (K_ASC4))
 #define XLAT_STR_4 STRINGIFY(K_ASC4)
 XLAT(K_ASC5),
 #define XLAT_VAL_5 ((unsigned) (K_ASC5))
 #define XLAT_STR_5 STRINGIFY(K_ASC5)
 XLAT(K_ASC6),
 #define XLAT_VAL_6 ((unsigned) (K_ASC6))
 #define XLAT_STR_6 STRINGIFY(K_ASC6)
 XLAT(K_ASC7),
 #define XLAT_VAL_7 ((unsigned) (K_ASC7))
 #define XLAT_STR_7 STRINGIFY(K_ASC7)
 XLAT(K_ASC8),
 #define XLAT_VAL_8 ((unsigned) (K_ASC8))
 #define XLAT_STR_8 STRINGIFY(K_ASC8)
 XLAT(K_ASC9),
 #define XLAT_VAL_9 ((unsigned) (K_ASC9))
 #define XLAT_STR_9 STRINGIFY(K_ASC9)
 XLAT(K_HEX0),
 #define XLAT_VAL_10 ((unsigned) (K_HEX0))
 #define XLAT_STR_10 STRINGIFY(K_HEX0)
 XLAT(K_HEX1),
 #define XLAT_VAL_11 ((unsigned) (K_HEX1))
 #define XLAT_STR_11 STRINGIFY(K_HEX1)
 XLAT(K_HEX2),
 #define XLAT_VAL_12 ((unsigned) (K_HEX2))
 #define XLAT_STR_12 STRINGIFY(K_HEX2)
 XLAT(K_HEX3),
 #define XLAT_VAL_13 ((unsigned) (K_HEX3))
 #define XLAT_STR_13 STRINGIFY(K_HEX3)
 XLAT(K_HEX4),
 #define XLAT_VAL_14 ((unsigned) (K_HEX4))
 #define XLAT_STR_14 STRINGIFY(K_HEX4)
 XLAT(K_HEX5),
 #define XLAT_VAL_15 ((unsigned) (K_HEX5))
 #define XLAT_STR_15 STRINGIFY(K_HEX5)
 XLAT(K_HEX6),
 #define XLAT_VAL_16 ((unsigned) (K_HEX6))
 #define XLAT_STR_16 STRINGIFY(K_HEX6)
 XLAT(K_HEX7),
 #define XLAT_VAL_17 ((unsigned) (K_HEX7))
 #define XLAT_STR_17 STRINGIFY(K_HEX7)
 XLAT(K_HEX8),
 #define XLAT_VAL_18 ((unsigned) (K_HEX8))
 #define XLAT_STR_18 STRINGIFY(K_HEX8)
 XLAT(K_HEX9),
 #define XLAT_VAL_19 ((unsigned) (K_HEX9))
 #define XLAT_STR_19 STRINGIFY(K_HEX9)
 XLAT(K_HEXa),
 #define XLAT_VAL_20 ((unsigned) (K_HEXa))
 #define XLAT_STR_20 STRINGIFY(K_HEXa)
 XLAT(K_HEXb),
 #define XLAT_VAL_21 ((unsigned) (K_HEXb))
 #define XLAT_STR_21 STRINGIFY(K_HEXb)
 XLAT(K_HEXc),
 #define XLAT_VAL_22 ((unsigned) (K_HEXc))
 #define XLAT_STR_22 STRINGIFY(K_HEXc)
 XLAT(K_HEXd),
 #define XLAT_VAL_23 ((unsigned) (K_HEXd))
 #define XLAT_STR_23 STRINGIFY(K_HEXd)
 XLAT(K_HEXe),
 #define XLAT_VAL_24 ((unsigned) (K_HEXe))
 #define XLAT_STR_24 STRINGIFY(K_HEXe)
 XLAT(K_HEXf),
 #define XLAT_VAL_25 ((unsigned) (K_HEXf))
 #define XLAT_STR_25 STRINGIFY(K_HEXf)
};
static
const struct xlat kd_key_ascii_keys[1] = { {
 .data = kd_key_ascii_keys_xdata,
 .size = ARRAY_SIZE(kd_key_ascii_keys_xdata),
 .type = XT_SORTED,
 .flags_mask = 0
#  ifdef XLAT_VAL_0
  | XLAT_VAL_0
#  endif
#  ifdef XLAT_VAL_1
  | XLAT_VAL_1
#  endif
#  ifdef XLAT_VAL_2
  | XLAT_VAL_2
#  endif
#  ifdef XLAT_VAL_3
  | XLAT_VAL_3
#  endif
#  ifdef XLAT_VAL_4
  | XLAT_VAL_4
#  endif
#  ifdef XLAT_VAL_5
  | XLAT_VAL_5
#  endif
#  ifdef XLAT_VAL_6
  | XLAT_VAL_6
#  endif
#  ifdef XLAT_VAL_7
  | XLAT_VAL_7
#  endif
#  ifdef XLAT_VAL_8
  | XLAT_VAL_8
#  endif
#  ifdef XLAT_VAL_9
  | XLAT_VAL_9
#  endif
#  ifdef XLAT_VAL_10
  | XLAT_VAL_10
#  endif
#  ifdef XLAT_VAL_11
  | XLAT_VAL_11
#  endif
#  ifdef XLAT_VAL_12
  | XLAT_VAL_12
#  endif
#  ifdef XLAT_VAL_13
  | XLAT_VAL_13
#  endif
#  ifdef XLAT_VAL_14
  | XLAT_VAL_14
#  endif
#  ifdef XLAT_VAL_15
  | XLAT_VAL_15
#  endif
#  ifdef XLAT_VAL_16
  | XLAT_VAL_16
#  endif
#  ifdef XLAT_VAL_17
  | XLAT_VAL_17
#  endif
#  ifdef XLAT_VAL_18
  | XLAT_VAL_18
#  endif
#  ifdef XLAT_VAL_19
  | XLAT_VAL_19
#  endif
#  ifdef XLAT_VAL_20
  | XLAT_VAL_20
#  endif
#  ifdef XLAT_VAL_21
  | XLAT_VAL_21
#  endif
#  ifdef XLAT_VAL_22
  | XLAT_VAL_22
#  endif
#  ifdef XLAT_VAL_23
  | XLAT_VAL_23
#  endif
#  ifdef XLAT_VAL_24
  | XLAT_VAL_24
#  endif
#  ifdef XLAT_VAL_25
  | XLAT_VAL_25
#  endif
  ,
 .flags_strsz = 0
#  ifdef XLAT_STR_0
  + sizeof(XLAT_STR_0)
#  endif
#  ifdef XLAT_STR_1
  + sizeof(XLAT_STR_1)
#  endif
#  ifdef XLAT_STR_2
  + sizeof(XLAT_STR_2)
#  endif
#  ifdef XLAT_STR_3
  + sizeof(XLAT_STR_3)
#  endif
#  ifdef XLAT_STR_4
  + sizeof(XLAT_STR_4)
#  endif
#  ifdef XLAT_STR_5
  + sizeof(XLAT_STR_5)
#  endif
#  ifdef XLAT_STR_6
  + sizeof(XLAT_STR_6)
#  endif
#  ifdef XLAT_STR_7
  + sizeof(XLAT_STR_7)
#  endif
#  ifdef XLAT_STR_8
  + sizeof(XLAT_STR_8)
#  endif
#  ifdef XLAT_STR_9
  + sizeof(XLAT_STR_9)
#  endif
#  ifdef XLAT_STR_10
  + sizeof(XLAT_STR_10)
#  endif
#  ifdef XLAT_STR_11
  + sizeof(XLAT_STR_11)
#  endif
#  ifdef XLAT_STR_12
  + sizeof(XLAT_STR_12)
#  endif
#  ifdef XLAT_STR_13
  + sizeof(XLAT_STR_13)
#  endif
#  ifdef XLAT_STR_14
  + sizeof(XLAT_STR_14)
#  endif
#  ifdef XLAT_STR_15
  + sizeof(XLAT_STR_15)
#  endif
#  ifdef XLAT_STR_16
  + sizeof(XLAT_STR_16)
#  endif
#  ifdef XLAT_STR_17
  + sizeof(XLAT_STR_17)
#  endif
#  ifdef XLAT_STR_18
  + sizeof(XLAT_STR_18)
#  endif
#  ifdef XLAT_STR_19
  + sizeof(XLAT_STR_19)
#  endif
#  ifdef XLAT_STR_20
  + sizeof(XLAT_STR_20)
#  endif
#  ifdef XLAT_STR_21
  + sizeof(XLAT_STR_21)
#  endif
#  ifdef XLAT_STR_22
  + sizeof(XLAT_STR_22)
#  endif
#  ifdef XLAT_STR_23
  + sizeof(XLAT_STR_23)
#  endif
#  ifdef XLAT_STR_24
  + sizeof(XLAT_STR_24)
#  endif
#  ifdef XLAT_STR_25
  + sizeof(XLAT_STR_25)
#  endif
  ,
} };
DIAG_POP_IGNORE_TAUTOLOGICAL_CONSTANT_COMPARE

#  undef XLAT_STR_0
#  undef XLAT_VAL_0
#  undef XLAT_STR_1
#  undef XLAT_VAL_1
#  undef XLAT_STR_2
#  undef XLAT_VAL_2
#  undef XLAT_STR_3
#  undef XLAT_VAL_3
#  undef XLAT_STR_4
#  undef XLAT_VAL_4
#  undef XLAT_STR_5
#  undef XLAT_VAL_5
#  undef XLAT_STR_6
#  undef XLAT_VAL_6
#  undef XLAT_STR_7
#  undef XLAT_VAL_7
#  undef XLAT_STR_8
#  undef XLAT_VAL_8
#  undef XLAT_STR_9
#  undef XLAT_VAL_9
#  undef XLAT_STR_10
#  undef XLAT_VAL_10
#  undef XLAT_STR_11
#  undef XLAT_VAL_11
#  undef XLAT_STR_12
#  undef XLAT_VAL_12
#  undef XLAT_STR_13
#  undef XLAT_VAL_13
#  undef XLAT_STR_14
#  undef XLAT_VAL_14
#  undef XLAT_STR_15
#  undef XLAT_VAL_15
#  undef XLAT_STR_16
#  undef XLAT_VAL_16
#  undef XLAT_STR_17
#  undef XLAT_VAL_17
#  undef XLAT_STR_18
#  undef XLAT_VAL_18
#  undef XLAT_STR_19
#  undef XLAT_VAL_19
#  undef XLAT_STR_20
#  undef XLAT_VAL_20
#  undef XLAT_STR_21
#  undef XLAT_VAL_21
#  undef XLAT_STR_22
#  undef XLAT_VAL_22
#  undef XLAT_STR_23
#  undef XLAT_VAL_23
#  undef XLAT_STR_24
#  undef XLAT_VAL_24
#  undef XLAT_STR_25
#  undef XLAT_VAL_25
# endif /* !IN_MPERS */

#endif /* !XLAT_MACROS_ONLY */
