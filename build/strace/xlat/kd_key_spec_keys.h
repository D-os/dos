/* Generated by ./src/xlat/gen.sh from ./src/xlat/kd_key_spec_keys.in; do not edit. */

#include "gcc_compat.h"
#include "static_assert.h"

#if defined(K_HOLE) || (defined(HAVE_DECL_K_HOLE) && HAVE_DECL_K_HOLE)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_HOLE) == (K(KT_SPEC,0)), "K_HOLE != K(KT_SPEC,0)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_HOLE K(KT_SPEC,0)
#endif
#if defined(K_HOLE) || (defined(HAVE_DECL_K_HOLE) && HAVE_DECL_K_HOLE)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_HOLE)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_HOLE"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_HOLE)
#endif
#if defined(K_ENTER) || (defined(HAVE_DECL_K_ENTER) && HAVE_DECL_K_ENTER)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_ENTER) == (K(KT_SPEC,1)), "K_ENTER != K(KT_SPEC,1)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_ENTER K(KT_SPEC,1)
#endif
#if defined(K_ENTER) || (defined(HAVE_DECL_K_ENTER) && HAVE_DECL_K_ENTER)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_ENTER)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_ENTER"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_ENTER)
#endif
#if defined(K_SH_REGS) || (defined(HAVE_DECL_K_SH_REGS) && HAVE_DECL_K_SH_REGS)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_SH_REGS) == (K(KT_SPEC,2)), "K_SH_REGS != K(KT_SPEC,2)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_SH_REGS K(KT_SPEC,2)
#endif
#if defined(K_SH_REGS) || (defined(HAVE_DECL_K_SH_REGS) && HAVE_DECL_K_SH_REGS)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_SH_REGS)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_SH_REGS"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_SH_REGS)
#endif
#if defined(K_SH_MEM) || (defined(HAVE_DECL_K_SH_MEM) && HAVE_DECL_K_SH_MEM)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_SH_MEM) == (K(KT_SPEC,3)), "K_SH_MEM != K(KT_SPEC,3)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_SH_MEM K(KT_SPEC,3)
#endif
#if defined(K_SH_MEM) || (defined(HAVE_DECL_K_SH_MEM) && HAVE_DECL_K_SH_MEM)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_SH_MEM)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_SH_MEM"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_SH_MEM)
#endif
#if defined(K_SH_STAT) || (defined(HAVE_DECL_K_SH_STAT) && HAVE_DECL_K_SH_STAT)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_SH_STAT) == (K(KT_SPEC,4)), "K_SH_STAT != K(KT_SPEC,4)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_SH_STAT K(KT_SPEC,4)
#endif
#if defined(K_SH_STAT) || (defined(HAVE_DECL_K_SH_STAT) && HAVE_DECL_K_SH_STAT)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_SH_STAT)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_SH_STAT"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_SH_STAT)
#endif
#if defined(K_BREAK) || (defined(HAVE_DECL_K_BREAK) && HAVE_DECL_K_BREAK)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_BREAK) == (K(KT_SPEC,5)), "K_BREAK != K(KT_SPEC,5)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_BREAK K(KT_SPEC,5)
#endif
#if defined(K_BREAK) || (defined(HAVE_DECL_K_BREAK) && HAVE_DECL_K_BREAK)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_BREAK)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_BREAK"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_BREAK)
#endif
#if defined(K_CONS) || (defined(HAVE_DECL_K_CONS) && HAVE_DECL_K_CONS)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_CONS) == (K(KT_SPEC,6)), "K_CONS != K(KT_SPEC,6)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_CONS K(KT_SPEC,6)
#endif
#if defined(K_CONS) || (defined(HAVE_DECL_K_CONS) && HAVE_DECL_K_CONS)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_CONS)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_CONS"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_CONS)
#endif
#if defined(K_CAPS) || (defined(HAVE_DECL_K_CAPS) && HAVE_DECL_K_CAPS)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_CAPS) == (K(KT_SPEC,7)), "K_CAPS != K(KT_SPEC,7)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_CAPS K(KT_SPEC,7)
#endif
#if defined(K_CAPS) || (defined(HAVE_DECL_K_CAPS) && HAVE_DECL_K_CAPS)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_CAPS)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_CAPS"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_CAPS)
#endif
#if defined(K_NUM) || (defined(HAVE_DECL_K_NUM) && HAVE_DECL_K_NUM)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_NUM) == (K(KT_SPEC,8)), "K_NUM != K(KT_SPEC,8)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_NUM K(KT_SPEC,8)
#endif
#if defined(K_NUM) || (defined(HAVE_DECL_K_NUM) && HAVE_DECL_K_NUM)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_NUM)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_NUM"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_NUM)
#endif
#if defined(K_HOLD) || (defined(HAVE_DECL_K_HOLD) && HAVE_DECL_K_HOLD)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_HOLD) == (K(KT_SPEC,9)), "K_HOLD != K(KT_SPEC,9)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_HOLD K(KT_SPEC,9)
#endif
#if defined(K_HOLD) || (defined(HAVE_DECL_K_HOLD) && HAVE_DECL_K_HOLD)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_HOLD)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_HOLD"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_HOLD)
#endif
#if defined(K_SCROLLFORW) || (defined(HAVE_DECL_K_SCROLLFORW) && HAVE_DECL_K_SCROLLFORW)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_SCROLLFORW) == (K(KT_SPEC,10)), "K_SCROLLFORW != K(KT_SPEC,10)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_SCROLLFORW K(KT_SPEC,10)
#endif
#if defined(K_SCROLLFORW) || (defined(HAVE_DECL_K_SCROLLFORW) && HAVE_DECL_K_SCROLLFORW)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_SCROLLFORW)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_SCROLLFORW"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_SCROLLFORW)
#endif
#if defined(K_SCROLLBACK) || (defined(HAVE_DECL_K_SCROLLBACK) && HAVE_DECL_K_SCROLLBACK)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_SCROLLBACK) == (K(KT_SPEC,11)), "K_SCROLLBACK != K(KT_SPEC,11)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_SCROLLBACK K(KT_SPEC,11)
#endif
#if defined(K_SCROLLBACK) || (defined(HAVE_DECL_K_SCROLLBACK) && HAVE_DECL_K_SCROLLBACK)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_SCROLLBACK)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_SCROLLBACK"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_SCROLLBACK)
#endif
#if defined(K_BOOT) || (defined(HAVE_DECL_K_BOOT) && HAVE_DECL_K_BOOT)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_BOOT) == (K(KT_SPEC,12)), "K_BOOT != K(KT_SPEC,12)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_BOOT K(KT_SPEC,12)
#endif
#if defined(K_BOOT) || (defined(HAVE_DECL_K_BOOT) && HAVE_DECL_K_BOOT)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_BOOT)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_BOOT"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_BOOT)
#endif
#if defined(K_CAPSON) || (defined(HAVE_DECL_K_CAPSON) && HAVE_DECL_K_CAPSON)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_CAPSON) == (K(KT_SPEC,13)), "K_CAPSON != K(KT_SPEC,13)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_CAPSON K(KT_SPEC,13)
#endif
#if defined(K_CAPSON) || (defined(HAVE_DECL_K_CAPSON) && HAVE_DECL_K_CAPSON)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_CAPSON)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_CAPSON"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_CAPSON)
#endif
#if defined(K_COMPOSE) || (defined(HAVE_DECL_K_COMPOSE) && HAVE_DECL_K_COMPOSE)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_COMPOSE) == (K(KT_SPEC,14)), "K_COMPOSE != K(KT_SPEC,14)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_COMPOSE K(KT_SPEC,14)
#endif
#if defined(K_COMPOSE) || (defined(HAVE_DECL_K_COMPOSE) && HAVE_DECL_K_COMPOSE)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_COMPOSE)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_COMPOSE"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_COMPOSE)
#endif
#if defined(K_SAK) || (defined(HAVE_DECL_K_SAK) && HAVE_DECL_K_SAK)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_SAK) == (K(KT_SPEC,15)), "K_SAK != K(KT_SPEC,15)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_SAK K(KT_SPEC,15)
#endif
#if defined(K_SAK) || (defined(HAVE_DECL_K_SAK) && HAVE_DECL_K_SAK)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_SAK)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_SAK"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_SAK)
#endif
#if defined(K_DECRCONSOLE) || (defined(HAVE_DECL_K_DECRCONSOLE) && HAVE_DECL_K_DECRCONSOLE)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_DECRCONSOLE) == (K(KT_SPEC,16)), "K_DECRCONSOLE != K(KT_SPEC,16)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_DECRCONSOLE K(KT_SPEC,16)
#endif
#if defined(K_DECRCONSOLE) || (defined(HAVE_DECL_K_DECRCONSOLE) && HAVE_DECL_K_DECRCONSOLE)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_DECRCONSOLE)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_DECRCONSOLE"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_DECRCONSOLE)
#endif
#if defined(K_INCRCONSOLE) || (defined(HAVE_DECL_K_INCRCONSOLE) && HAVE_DECL_K_INCRCONSOLE)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_INCRCONSOLE) == (K(KT_SPEC,17)), "K_INCRCONSOLE != K(KT_SPEC,17)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_INCRCONSOLE K(KT_SPEC,17)
#endif
#if defined(K_INCRCONSOLE) || (defined(HAVE_DECL_K_INCRCONSOLE) && HAVE_DECL_K_INCRCONSOLE)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_INCRCONSOLE)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_INCRCONSOLE"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_INCRCONSOLE)
#endif
#if defined(K_SPAWNCONSOLE) || (defined(HAVE_DECL_K_SPAWNCONSOLE) && HAVE_DECL_K_SPAWNCONSOLE)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_SPAWNCONSOLE) == (K(KT_SPEC,18)), "K_SPAWNCONSOLE != K(KT_SPEC,18)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_SPAWNCONSOLE K(KT_SPEC,18)
#endif
#if defined(K_SPAWNCONSOLE) || (defined(HAVE_DECL_K_SPAWNCONSOLE) && HAVE_DECL_K_SPAWNCONSOLE)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_SPAWNCONSOLE)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_SPAWNCONSOLE"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_SPAWNCONSOLE)
#endif
#if defined(K_BARENUMLOCK) || (defined(HAVE_DECL_K_BARENUMLOCK) && HAVE_DECL_K_BARENUMLOCK)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_BARENUMLOCK) == (K(KT_SPEC,19)), "K_BARENUMLOCK != K(KT_SPEC,19)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_BARENUMLOCK K(KT_SPEC,19)
#endif
#if defined(K_BARENUMLOCK) || (defined(HAVE_DECL_K_BARENUMLOCK) && HAVE_DECL_K_BARENUMLOCK)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_BARENUMLOCK)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_BARENUMLOCK"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_BARENUMLOCK)
#endif
#if defined(K_ALLOCATED) || (defined(HAVE_DECL_K_ALLOCATED) && HAVE_DECL_K_ALLOCATED)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_ALLOCATED) == (K(KT_SPEC,126)), "K_ALLOCATED != K(KT_SPEC,126)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_ALLOCATED K(KT_SPEC,126)
#endif
#if defined(K_ALLOCATED) || (defined(HAVE_DECL_K_ALLOCATED) && HAVE_DECL_K_ALLOCATED)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_ALLOCATED)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_ALLOCATED"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_ALLOCATED)
#endif
#if defined(K_NOSUCHMAP) || (defined(HAVE_DECL_K_NOSUCHMAP) && HAVE_DECL_K_NOSUCHMAP)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((K_NOSUCHMAP) == (K(KT_SPEC,127)), "K_NOSUCHMAP != K(KT_SPEC,127)");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define K_NOSUCHMAP K(KT_SPEC,127)
#endif
#if defined(K_NOSUCHMAP) || (defined(HAVE_DECL_K_NOSUCHMAP) && HAVE_DECL_K_NOSUCHMAP)
#if defined XLAT_PREV_VAL
static_assert((unsigned long long) (K_NOSUCHMAP)
      > (unsigned long long) (XLAT_PREV_VAL),
      "Incorrect order in #sorted xlat: K_NOSUCHMAP"
      " is not larger than the previous value");
#endif
#undef XLAT_PREV_VAL
#define XLAT_PREV_VAL (K_NOSUCHMAP)
#endif
#undef XLAT_PREV_VAL

#ifndef XLAT_MACROS_ONLY

# ifdef IN_MPERS

#  error static const struct xlat kd_key_spec_keys in mpers mode

# else

DIAG_PUSH_IGNORE_TAUTOLOGICAL_CONSTANT_COMPARE
static const struct xlat_data kd_key_spec_keys_xdata[] = {
 XLAT(K_HOLE),
 #define XLAT_VAL_0 ((unsigned) (K_HOLE))
 #define XLAT_STR_0 STRINGIFY(K_HOLE)
 XLAT(K_ENTER),
 #define XLAT_VAL_1 ((unsigned) (K_ENTER))
 #define XLAT_STR_1 STRINGIFY(K_ENTER)
 XLAT(K_SH_REGS),
 #define XLAT_VAL_2 ((unsigned) (K_SH_REGS))
 #define XLAT_STR_2 STRINGIFY(K_SH_REGS)
 XLAT(K_SH_MEM),
 #define XLAT_VAL_3 ((unsigned) (K_SH_MEM))
 #define XLAT_STR_3 STRINGIFY(K_SH_MEM)
 XLAT(K_SH_STAT),
 #define XLAT_VAL_4 ((unsigned) (K_SH_STAT))
 #define XLAT_STR_4 STRINGIFY(K_SH_STAT)
 XLAT(K_BREAK),
 #define XLAT_VAL_5 ((unsigned) (K_BREAK))
 #define XLAT_STR_5 STRINGIFY(K_BREAK)
 XLAT(K_CONS),
 #define XLAT_VAL_6 ((unsigned) (K_CONS))
 #define XLAT_STR_6 STRINGIFY(K_CONS)
 XLAT(K_CAPS),
 #define XLAT_VAL_7 ((unsigned) (K_CAPS))
 #define XLAT_STR_7 STRINGIFY(K_CAPS)
 XLAT(K_NUM),
 #define XLAT_VAL_8 ((unsigned) (K_NUM))
 #define XLAT_STR_8 STRINGIFY(K_NUM)
 XLAT(K_HOLD),
 #define XLAT_VAL_9 ((unsigned) (K_HOLD))
 #define XLAT_STR_9 STRINGIFY(K_HOLD)
 XLAT(K_SCROLLFORW),
 #define XLAT_VAL_10 ((unsigned) (K_SCROLLFORW))
 #define XLAT_STR_10 STRINGIFY(K_SCROLLFORW)
 XLAT(K_SCROLLBACK),
 #define XLAT_VAL_11 ((unsigned) (K_SCROLLBACK))
 #define XLAT_STR_11 STRINGIFY(K_SCROLLBACK)
 XLAT(K_BOOT),
 #define XLAT_VAL_12 ((unsigned) (K_BOOT))
 #define XLAT_STR_12 STRINGIFY(K_BOOT)
 XLAT(K_CAPSON),
 #define XLAT_VAL_13 ((unsigned) (K_CAPSON))
 #define XLAT_STR_13 STRINGIFY(K_CAPSON)
 XLAT(K_COMPOSE),
 #define XLAT_VAL_14 ((unsigned) (K_COMPOSE))
 #define XLAT_STR_14 STRINGIFY(K_COMPOSE)
 XLAT(K_SAK),
 #define XLAT_VAL_15 ((unsigned) (K_SAK))
 #define XLAT_STR_15 STRINGIFY(K_SAK)
 XLAT(K_DECRCONSOLE),
 #define XLAT_VAL_16 ((unsigned) (K_DECRCONSOLE))
 #define XLAT_STR_16 STRINGIFY(K_DECRCONSOLE)
 XLAT(K_INCRCONSOLE),
 #define XLAT_VAL_17 ((unsigned) (K_INCRCONSOLE))
 #define XLAT_STR_17 STRINGIFY(K_INCRCONSOLE)
 XLAT(K_SPAWNCONSOLE),
 #define XLAT_VAL_18 ((unsigned) (K_SPAWNCONSOLE))
 #define XLAT_STR_18 STRINGIFY(K_SPAWNCONSOLE)
 XLAT(K_BARENUMLOCK),
 #define XLAT_VAL_19 ((unsigned) (K_BARENUMLOCK))
 #define XLAT_STR_19 STRINGIFY(K_BARENUMLOCK)
 XLAT(K_ALLOCATED),
 #define XLAT_VAL_20 ((unsigned) (K_ALLOCATED))
 #define XLAT_STR_20 STRINGIFY(K_ALLOCATED)
 XLAT(K_NOSUCHMAP),
 #define XLAT_VAL_21 ((unsigned) (K_NOSUCHMAP))
 #define XLAT_STR_21 STRINGIFY(K_NOSUCHMAP)
};
static
const struct xlat kd_key_spec_keys[1] = { {
 .data = kd_key_spec_keys_xdata,
 .size = ARRAY_SIZE(kd_key_spec_keys_xdata),
 .type = XT_SORTED,
 .flags_mask = 0
#  ifdef XLAT_VAL_0
  | XLAT_VAL_0
#  endif
#  ifdef XLAT_VAL_1
  | XLAT_VAL_1
#  endif
#  ifdef XLAT_VAL_2
  | XLAT_VAL_2
#  endif
#  ifdef XLAT_VAL_3
  | XLAT_VAL_3
#  endif
#  ifdef XLAT_VAL_4
  | XLAT_VAL_4
#  endif
#  ifdef XLAT_VAL_5
  | XLAT_VAL_5
#  endif
#  ifdef XLAT_VAL_6
  | XLAT_VAL_6
#  endif
#  ifdef XLAT_VAL_7
  | XLAT_VAL_7
#  endif
#  ifdef XLAT_VAL_8
  | XLAT_VAL_8
#  endif
#  ifdef XLAT_VAL_9
  | XLAT_VAL_9
#  endif
#  ifdef XLAT_VAL_10
  | XLAT_VAL_10
#  endif
#  ifdef XLAT_VAL_11
  | XLAT_VAL_11
#  endif
#  ifdef XLAT_VAL_12
  | XLAT_VAL_12
#  endif
#  ifdef XLAT_VAL_13
  | XLAT_VAL_13
#  endif
#  ifdef XLAT_VAL_14
  | XLAT_VAL_14
#  endif
#  ifdef XLAT_VAL_15
  | XLAT_VAL_15
#  endif
#  ifdef XLAT_VAL_16
  | XLAT_VAL_16
#  endif
#  ifdef XLAT_VAL_17
  | XLAT_VAL_17
#  endif
#  ifdef XLAT_VAL_18
  | XLAT_VAL_18
#  endif
#  ifdef XLAT_VAL_19
  | XLAT_VAL_19
#  endif
#  ifdef XLAT_VAL_20
  | XLAT_VAL_20
#  endif
#  ifdef XLAT_VAL_21
  | XLAT_VAL_21
#  endif
  ,
 .flags_strsz = 0
#  ifdef XLAT_STR_0
  + sizeof(XLAT_STR_0)
#  endif
#  ifdef XLAT_STR_1
  + sizeof(XLAT_STR_1)
#  endif
#  ifdef XLAT_STR_2
  + sizeof(XLAT_STR_2)
#  endif
#  ifdef XLAT_STR_3
  + sizeof(XLAT_STR_3)
#  endif
#  ifdef XLAT_STR_4
  + sizeof(XLAT_STR_4)
#  endif
#  ifdef XLAT_STR_5
  + sizeof(XLAT_STR_5)
#  endif
#  ifdef XLAT_STR_6
  + sizeof(XLAT_STR_6)
#  endif
#  ifdef XLAT_STR_7
  + sizeof(XLAT_STR_7)
#  endif
#  ifdef XLAT_STR_8
  + sizeof(XLAT_STR_8)
#  endif
#  ifdef XLAT_STR_9
  + sizeof(XLAT_STR_9)
#  endif
#  ifdef XLAT_STR_10
  + sizeof(XLAT_STR_10)
#  endif
#  ifdef XLAT_STR_11
  + sizeof(XLAT_STR_11)
#  endif
#  ifdef XLAT_STR_12
  + sizeof(XLAT_STR_12)
#  endif
#  ifdef XLAT_STR_13
  + sizeof(XLAT_STR_13)
#  endif
#  ifdef XLAT_STR_14
  + sizeof(XLAT_STR_14)
#  endif
#  ifdef XLAT_STR_15
  + sizeof(XLAT_STR_15)
#  endif
#  ifdef XLAT_STR_16
  + sizeof(XLAT_STR_16)
#  endif
#  ifdef XLAT_STR_17
  + sizeof(XLAT_STR_17)
#  endif
#  ifdef XLAT_STR_18
  + sizeof(XLAT_STR_18)
#  endif
#  ifdef XLAT_STR_19
  + sizeof(XLAT_STR_19)
#  endif
#  ifdef XLAT_STR_20
  + sizeof(XLAT_STR_20)
#  endif
#  ifdef XLAT_STR_21
  + sizeof(XLAT_STR_21)
#  endif
  ,
} };
DIAG_POP_IGNORE_TAUTOLOGICAL_CONSTANT_COMPARE

#  undef XLAT_STR_0
#  undef XLAT_VAL_0
#  undef XLAT_STR_1
#  undef XLAT_VAL_1
#  undef XLAT_STR_2
#  undef XLAT_VAL_2
#  undef XLAT_STR_3
#  undef XLAT_VAL_3
#  undef XLAT_STR_4
#  undef XLAT_VAL_4
#  undef XLAT_STR_5
#  undef XLAT_VAL_5
#  undef XLAT_STR_6
#  undef XLAT_VAL_6
#  undef XLAT_STR_7
#  undef XLAT_VAL_7
#  undef XLAT_STR_8
#  undef XLAT_VAL_8
#  undef XLAT_STR_9
#  undef XLAT_VAL_9
#  undef XLAT_STR_10
#  undef XLAT_VAL_10
#  undef XLAT_STR_11
#  undef XLAT_VAL_11
#  undef XLAT_STR_12
#  undef XLAT_VAL_12
#  undef XLAT_STR_13
#  undef XLAT_VAL_13
#  undef XLAT_STR_14
#  undef XLAT_VAL_14
#  undef XLAT_STR_15
#  undef XLAT_VAL_15
#  undef XLAT_STR_16
#  undef XLAT_VAL_16
#  undef XLAT_STR_17
#  undef XLAT_VAL_17
#  undef XLAT_STR_18
#  undef XLAT_VAL_18
#  undef XLAT_STR_19
#  undef XLAT_VAL_19
#  undef XLAT_STR_20
#  undef XLAT_VAL_20
#  undef XLAT_STR_21
#  undef XLAT_VAL_21
# endif /* !IN_MPERS */

#endif /* !XLAT_MACROS_ONLY */
